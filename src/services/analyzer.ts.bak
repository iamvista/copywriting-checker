import { AnalysisResult, DimensionScore, AnalysisSummary } from '@/types/analyzer.types'
import { SCORE_THRESHOLDS } from '@/utils/constants'

// å°å…¥çŸ¥è­˜åº«è¦å‰‡
import fabRules from '../../knowledge-base/rules/fab-rules.json'
import titleRules from '../../knowledge-base/rules/title-rules.json'
import ctaRules from '../../knowledge-base/rules/cta-rules.json'
import readabilityRules from '../../knowledge-base/rules/readability-rules.json'
import valueRules from '../../knowledge-base/rules/value-proposition-rules.json'
import suggestionTemplates from '../../knowledge-base/templates/suggestions.json'

// ========== å·¥å…·å‡½æ•¸ ==========

/**
 * æª¢æŸ¥æ–‡æœ¬ä¸­æ˜¯å¦åŒ…å«æŒ‡å®šçš„é—œéµå­—
 */
function containsKeywords(text: string, keywords: string[]): boolean {
  return keywords.some(keyword => text.includes(keyword))
}

/**
 * æª¢æŸ¥æ–‡æœ¬æ˜¯å¦ç¬¦åˆæ­£å‰‡è¡¨é”å¼æ¨¡å¼
 */
function matchesPatterns(text: string, patterns: string[]): boolean {
  return patterns.some(pattern => {
    try {
      const regex = new RegExp(pattern)
      return regex.test(text)
    } catch (e) {
      console.warn(`Invalid regex pattern: ${pattern}`)
      return false
    }
  })
}


// ========== FAB æ³•å‰‡åˆ†æ ==========

function analyzeFAB(text: string): DimensionScore {
  let score = 0
  const feedback: string[] = []
  const suggestions: string[] = []

  // æª¢æŸ¥ Featureï¼ˆç‰¹æ€§ï¼‰
  const hasFeature =
    containsKeywords(text, fabRules.rules.feature.keywords) ||
    matchesPatterns(text, fabRules.rules.feature.patterns)

  if (hasFeature) {
    score += fabRules.rules.feature.scoring.present
    feedback.push(`âœ“ ${fabRules.rules.feature.scoring.message.success}`)
  } else {
    feedback.push(`âš ï¸ ${fabRules.rules.feature.scoring.message.warning}`)
  }

  // æª¢æŸ¥ Advantageï¼ˆå„ªå‹¢ï¼‰
  const hasAdvantage =
    containsKeywords(text, fabRules.rules.advantage.keywords) ||
    matchesPatterns(text, fabRules.rules.advantage.patterns)

  if (hasAdvantage) {
    score += fabRules.rules.advantage.scoring.present
    feedback.push(`âœ“ ${fabRules.rules.advantage.scoring.message.success}`)
  } else {
    feedback.push(`âš ï¸ ${fabRules.rules.advantage.scoring.message.warning}`)
    suggestions.push('å»ºè­°ï¼šèªªæ˜èˆ‡ç«¶å“çš„å·®ç•°ï¼Œä¾‹å¦‚ã€Œç¨å®¶ã€ã€ã€Œå”¯ä¸€ã€ã€ã€Œæ¯”...æ›´å¥½ã€')
  }

  // æª¢æŸ¥ Benefitï¼ˆæ•ˆç›Šï¼‰- æœ€é‡è¦ï¼
  const hasBenefit =
    containsKeywords(text, fabRules.rules.benefit.keywords) ||
    matchesPatterns(text, fabRules.rules.benefit.patterns)

  if (hasBenefit) {
    score += fabRules.rules.benefit.scoring.present
    feedback.push(`âœ“ ${fabRules.rules.benefit.scoring.message.success}`)
  } else {
    feedback.push(`ğŸš¨ ${fabRules.rules.benefit.scoring.message.critical}`)
    suggestions.push('å»ºè­°ï¼šç”¨ã€Œè®“æ‚¨...ã€ã€ã€Œå¹«æ‚¨...ã€èªªæ˜å°é¡§å®¢çš„å…·é«”å¥½è™•')
    suggestions.push('è¨˜ä½ï¼šFeatures tell, but benefits sellï¼ˆåŠŸèƒ½å‘ŠçŸ¥ï¼Œåˆ©ç›Šæ‰è³£ï¼‰')
  }

  // æ ¹æ“š FAB å®Œæ•´åº¦çµ¦äºˆé¡å¤–å»ºè­°
  if (score < 60) {
    suggestions.push('ğŸ’¡ Vista æé†’ï¼šä¸è¦åªåœç•™åœ¨ Fï¼ˆç‰¹æ€§ï¼‰å±¤é¢ï¼Œä¸€å®šè¦èªªåˆ° Bï¼ˆæ•ˆç›Šï¼‰')
  }

  // ç¢ºä¿åˆ†æ•¸ä¸è¶…é 100
  score = Math.min(score, 100)

  return { score, feedback, suggestions }
}

// ========== æ¨™é¡Œå¸å¼•åŠ›åˆ†æ ==========

function analyzeTitleAppeal(text: string): DimensionScore {
  let score = 0
  const feedback: string[] = []
  const suggestions: string[] = []

  // 1. æª¢æŸ¥æ•¸å­—
  if (matchesPatterns(text, titleRules.elements.numbers.patterns)) {
    score += titleRules.elements.numbers.weight
    feedback.push(titleRules.elements.numbers.message.present)
  } else {
    feedback.push(titleRules.elements.numbers.message.absent)
    suggestions.push(suggestionTemplates.dimensions.title_appeal.suggestions.add_numbers.template)
  }

  // 2. æª¢æŸ¥ç–‘å•å¥
  if (matchesPatterns(text, titleRules.elements.questions.patterns)) {
    score += titleRules.elements.questions.weight
    feedback.push(titleRules.elements.questions.message.present)
  } else {
    feedback.push(titleRules.elements.questions.message.absent)
    suggestions.push(suggestionTemplates.dimensions.title_appeal.suggestions.add_question.template)
  }

  // 3. æª¢æŸ¥ç—›é»é—œéµå­—
  if (containsKeywords(text, titleRules.elements.pain_points.keywords)) {
    score += titleRules.elements.pain_points.weight
    feedback.push(titleRules.elements.pain_points.message.present)
  } else {
    feedback.push(titleRules.elements.pain_points.message.absent)
    suggestions.push(suggestionTemplates.dimensions.title_appeal.suggestions.add_pain_point.template)
  }

  // 4. æª¢æŸ¥å¥½å¥‡å¿ƒè§¸ç™¼è©
  if (containsKeywords(text, titleRules.elements.curiosity.keywords)) {
    score += titleRules.elements.curiosity.weight
    feedback.push(titleRules.elements.curiosity.message.present)
  } else {
    feedback.push(titleRules.elements.curiosity.message.absent)
    suggestions.push(suggestionTemplates.dimensions.title_appeal.suggestions.add_curiosity.template)
  }

  // 5. æª¢æŸ¥æƒ…ç·’è©å½™
  if (containsKeywords(text, titleRules.elements.emotion.keywords)) {
    score += titleRules.elements.emotion.weight
    feedback.push(titleRules.elements.emotion.message.present)
  } else {
    feedback.push(titleRules.elements.emotion.message.absent)
  }

  // 6. æª¢æŸ¥æ¬Šå¨/åäººï¼ˆåŠ åˆ†é …ï¼‰
  if (containsKeywords(text, titleRules.elements.authority.keywords) ||
      matchesPatterns(text, titleRules.elements.authority.patterns)) {
    score += titleRules.elements.authority.weight
    feedback.push(titleRules.elements.authority.message.present)
  }

  // 7. æª¢æŸ¥ç·Šè¿«æ„Ÿï¼ˆåŠ åˆ†é …ï¼‰
  if (containsKeywords(text, titleRules.elements.urgency.keywords)) {
    score += titleRules.elements.urgency.weight
    feedback.push(titleRules.elements.urgency.message.present)
  } else {
    suggestions.push(suggestionTemplates.dimensions.title_appeal.suggestions.add_urgency.template)
  }

  // ç¢ºä¿åˆ†æ•¸ä¸è¶…é 100
  score = Math.min(score, 100)

  return { score, feedback, suggestions }
}

// ========== æ¶ˆè²»è€…æ´å¯Ÿåˆ†æ ==========

function analyzeConsumerInsight(text: string): DimensionScore {
  let score = 0
  const feedback: string[] = []
  const suggestions: string[] = []

  // æª¢æŸ¥ç›®æ¨™å—çœ¾å®šç¾©ï¼ˆä½¿ç”¨ title pain_points ä½œç‚ºç—›é»é—œéµå­—ï¼‰
  const audienceKeywords = ['å‰µæ¥­è€…', 'ä¸»ç®¡', 'å®¶é•·', 'å­¸ç”Ÿ', 'ä¸Šç­æ—', 'è€é—†', 'ç¶“ç†', 'è¡ŒéŠ·äºº', 'æ‚¨']
  const hasAudience = containsKeywords(text, audienceKeywords)

  if (hasAudience) {
    score += 25
    feedback.push('âœ“ æœ‰æ˜ç¢ºçš„ç›®æ¨™å—çœ¾')
  } else {
    feedback.push('âœ— ç›®æ¨™å—çœ¾ä¸æ˜ç¢º')
    suggestions.push(suggestionTemplates.dimensions.consumer_insight.suggestions.define_audience.template)
  }

  // æª¢æŸ¥ç—›é»æƒ…å¢ƒ
  const painKeywords = ['æ“”å¿ƒ', 'å›°æ“¾', 'æ¸´æœ›', 'å®³æ€•', 'æƒ³è¦', 'éœ€è¦', 'å¸Œæœ›', 'æ˜¯å¦', 'å¸¸å¸¸']
  const hasPainScenario = containsKeywords(text, painKeywords)

  if (hasPainScenario) {
    score += 30
    feedback.push('âœ“ æœ‰æè¿°ç—›é»æƒ…å¢ƒ')
  } else {
    feedback.push('âœ— ç¼ºå°‘å…·é«”ç—›é»æƒ…å¢ƒ')
    suggestions.push(suggestionTemplates.dimensions.consumer_insight.suggestions.add_pain_scenario.template)
  }

  // æª¢æŸ¥æƒ…ç·’é€£çµ
  const emotionWords = ['æ„Ÿåˆ°', 'è¦ºå¾—', 'ç¶“æ­·', 'é‡åˆ°', 'é¢å°', 'é«”é©—']
  const hasEmotion = containsKeywords(text, emotionWords)

  if (hasEmotion) {
    score += 25
    feedback.push('âœ“ æœ‰æƒ…ç·’é€£çµ')
  } else {
    feedback.push('âœ— ç¼ºå°‘æƒ…ç·’é€£çµ')
  }

  // æª¢æŸ¥åŒç†å¿ƒè¡¨é”
  const empathyWords = ['æˆ‘æ‡‚', 'ä¹Ÿæ›¾ç¶“', 'ç›¸ä¿¡æ‚¨', 'äº†è§£', 'çŸ¥é“', 'æ˜ç™½']
  const hasEmpathy = containsKeywords(text, empathyWords)

  if (hasEmpathy) {
    score += 20
    feedback.push('âœ“ æœ‰åŒç†å¿ƒè¡¨é”')
  } else {
    feedback.push('âœ— ç¼ºå°‘åŒç†å¿ƒè¡¨é”')
    suggestions.push(suggestionTemplates.dimensions.consumer_insight.suggestions.add_empathy.template)
  }

  // ç¢ºä¿åˆ†æ•¸ä¸è¶…é 100
  score = Math.min(score, 100)

  return { score, feedback, suggestions }
}

// ========== è¡Œå‹•å‘¼ç±²åˆ†æ ==========

function analyzeCallToAction(text: string): DimensionScore {
  let score = 0
  const feedback: string[] = []
  const suggestions: string[] = []

  // 1. æ˜ç¢ºæŒ‡ç¤ºï¼ˆæ¬Šé‡æœ€é«˜ï¼š40%ï¼‰
  const hasClearInstruction =
    containsKeywords(text, ctaRules.elements.clear_instruction.keywords) ||
    matchesPatterns(text, ctaRules.elements.clear_instruction.patterns)

  if (hasClearInstruction) {
    score += ctaRules.elements.clear_instruction.weight
    feedback.push(ctaRules.elements.clear_instruction.message.present)
  } else {
    feedback.push(ctaRules.elements.clear_instruction.message.absent)
    suggestions.push(suggestionTemplates.dimensions.call_to_action.suggestions.make_clear.template)
  }

  // 2. è¡Œå‹•å‹•è©ï¼ˆ20%ï¼‰
  const hasActionVerbs = containsKeywords(text, ctaRules.elements.action_verbs.keywords)

  if (hasActionVerbs) {
    score += ctaRules.elements.action_verbs.weight
    feedback.push(ctaRules.elements.action_verbs.message.present)
  } else {
    feedback.push(ctaRules.elements.action_verbs.message.absent)
  }

  // 3. æ€¥è¿«æ„Ÿï¼ˆ20%ï¼‰
  const hasUrgency =
    containsKeywords(text, ctaRules.elements.urgency.keywords) ||
    matchesPatterns(text, ctaRules.elements.urgency.patterns)

  if (hasUrgency) {
    score += ctaRules.elements.urgency.weight
    feedback.push(ctaRules.elements.urgency.message.present)
  } else {
    feedback.push(ctaRules.elements.urgency.message.absent)
    suggestions.push(suggestionTemplates.dimensions.call_to_action.suggestions.add_urgency.template)
  }

  // 4. é™ä½é–€æª»ï¼ˆ20%ï¼‰
  const hasLowBarrier = containsKeywords(text, ctaRules.elements.low_barrier.keywords)

  if (hasLowBarrier) {
    score += ctaRules.elements.low_barrier.weight
    feedback.push(ctaRules.elements.low_barrier.message.present)
  } else {
    feedback.push(ctaRules.elements.low_barrier.message.absent)
    suggestions.push(suggestionTemplates.dimensions.call_to_action.suggestions.lower_barrier.template)
  }

  // 5. åˆ©ç›Šæé†’ï¼ˆåŠ åˆ†é …ï¼š15%ï¼‰
  const hasBenefitReminder = containsKeywords(text, ctaRules.elements.benefit_reminder.keywords)

  if (hasBenefitReminder) {
    score += ctaRules.elements.benefit_reminder.weight
    feedback.push(ctaRules.elements.benefit_reminder.message.present)
  } else {
    suggestions.push(suggestionTemplates.dimensions.call_to_action.suggestions.add_benefit.template)
  }

  // 6. ç¤¾æœƒèªåŒï¼ˆåŠ åˆ†é …ï¼š10%ï¼‰
  const hasSocialProof =
    containsKeywords(text, ctaRules.elements.social_proof.keywords) ||
    matchesPatterns(text, ctaRules.elements.social_proof.patterns)

  if (hasSocialProof) {
    score += ctaRules.elements.social_proof.weight
    feedback.push(ctaRules.elements.social_proof.message.present)
  }

  // ç¢ºä¿åˆ†æ•¸ä¸è¶…é 100
  score = Math.min(score, 100)

  return { score, feedback, suggestions }
}

// ========== å¯è®€æ€§åˆ†æ ==========

function analyzeReadability(text: string): DimensionScore {
  let score = 0
  const feedback: string[] = []
  const suggestions: string[] = []

  // 1. å¥å­é•·åº¦ï¼ˆ25%ï¼‰
  const sentences = text.split(/[ã€‚ï¼ï¼Ÿ!?]/).filter(s => s.trim().length > 0)
  const avgSentenceLength = sentences.length > 0 ? text.length / sentences.length : text.length

  if (avgSentenceLength <= readabilityRules.criteria.sentence_length.rules.ideal.max_length) {
    score += readabilityRules.criteria.sentence_length.rules.ideal.score
    feedback.push(readabilityRules.criteria.sentence_length.rules.ideal.message)
  } else if (avgSentenceLength <= readabilityRules.criteria.sentence_length.rules.acceptable.max_length) {
    score += readabilityRules.criteria.sentence_length.rules.acceptable.score
    feedback.push(readabilityRules.criteria.sentence_length.rules.acceptable.message)
  } else {
    feedback.push(readabilityRules.criteria.sentence_length.rules.too_long.message)
    suggestions.push(suggestionTemplates.dimensions.readability.suggestions.shorten_sentences.template)
  }

  // 2. æ®µè½çµæ§‹ï¼ˆ25%ï¼‰
  const paragraphs = text.split('\n').filter(p => p.trim().length > 0)
  const hasGoodParagraphs = paragraphs.length > 1 || text.length < 150

  if (hasGoodParagraphs) {
    score += 25
    feedback.push('âœ“ æ®µè½çµæ§‹é©ä¸­')
  } else {
    score += 5
    feedback.push('âœ— æ®µè½éé•·ï¼Œå»ºè­°é©ç•¶åˆ†æ®µ')
    suggestions.push(suggestionTemplates.dimensions.readability.suggestions.add_paragraphs.template)
  }

  // 3. æ¨™é»ç¬¦è™Ÿä½¿ç”¨ï¼ˆ20%ï¼‰
  const hasPunctuation = /[ï¼Œã€‚ï¼ï¼Ÿã€ï¼šï¼›,;:!?]/.test(text)
  const exclamationCount = (text.match(/[ï¼!]/g) || []).length

  if (hasPunctuation && exclamationCount <= readabilityRules.criteria.punctuation.rules.excessive_exclamation.threshold) {
    score += 20
    feedback.push('âœ“ æ¨™é»ç¬¦è™Ÿä½¿ç”¨å¾—ç•¶')
  } else if (exclamationCount > readabilityRules.criteria.punctuation.rules.excessive_exclamation.threshold) {
    score += 10
    feedback.push('âš ï¸ é©šå˜†è™Ÿéå¤šï¼Œå»ºè­°æ¸›å°‘ä½¿ç”¨')
  } else {
    score += 5
    feedback.push('âœ— ç¼ºå°‘æ¨™é»ç¬¦è™Ÿï¼Œå¥å­ä¸æ˜“æ–·å¥')
  }

  // 4. å°ˆæ¥­è¡“èªï¼ˆ15%ï¼‰
  const technicalTerms = text.match(/[A-Z]{2,}/g) || []
  const jargonCount = technicalTerms.length

  if (jargonCount <= readabilityRules.criteria.jargon.rules.minimal_jargon.threshold) {
    score += readabilityRules.criteria.jargon.rules.minimal_jargon.score
    feedback.push(readabilityRules.criteria.jargon.rules.minimal_jargon.message)
  } else if (jargonCount <= readabilityRules.criteria.jargon.rules.moderate_jargon.threshold) {
    score += readabilityRules.criteria.jargon.rules.moderate_jargon.score
    feedback.push(readabilityRules.criteria.jargon.rules.moderate_jargon.message)
    suggestions.push(suggestionTemplates.dimensions.readability.suggestions.simplify_jargon.template)
  } else {
    feedback.push(readabilityRules.criteria.jargon.rules.excessive_jargon.message)
    suggestions.push(suggestionTemplates.dimensions.readability.suggestions.simplify_jargon.template)
  }

  // 5. ç•™ç™½èˆ‡åˆ†æ®µï¼ˆ15%ï¼‰
  const hasWhitespace = /\s/.test(text) && paragraphs.length >= 2

  if (hasWhitespace) {
    score += 15
    feedback.push('âœ“ æœ‰é©ç•¶ç•™ç™½ï¼Œé–±è®€èˆ’é©')
  } else {
    score += 5
    feedback.push('âœ— å…§å®¹éæ–¼å¯†é›†')
    suggestions.push(suggestionTemplates.dimensions.readability.suggestions.use_lists.template)
  }

  // ç¢ºä¿åˆ†æ•¸ä¸è¶…é 100
  score = Math.min(score, 100)

  return { score, feedback, suggestions }
}

// ========== åƒ¹å€¼ä¸»å¼µåˆ†æ ==========

function analyzeValueProposition(text: string): DimensionScore {
  let score = 0
  const feedback: string[] = []
  const suggestions: string[] = []

  // 1. æ¸…æ¥šèªªæ˜èƒ½å¾—åˆ°ä»€éº¼ï¼ˆ30%ï¼‰
  const hasClearBenefits =
    containsKeywords(text, valueRules.core_elements.clear_benefits.keywords) ||
    matchesPatterns(text, valueRules.core_elements.clear_benefits.patterns)

  if (hasClearBenefits) {
    score += valueRules.core_elements.clear_benefits.weight
    feedback.push(valueRules.core_elements.clear_benefits.scoring.explicit.message)
  } else {
    feedback.push(valueRules.core_elements.clear_benefits.scoring.absent.message)
    suggestions.push(suggestionTemplates.dimensions.value_proposition.suggestions.add_specific_benefits.template)
  }

  // 2. å…·é«”æ•¸å­—æˆ–è­‰æ“šï¼ˆ25%ï¼‰
  const hasNumbers = matchesPatterns(text, valueRules.core_elements.concrete_evidence.types.numbers.patterns)
  const hasTimeframe = matchesPatterns(text, valueRules.core_elements.concrete_evidence.types.timeframe.patterns)
  const hasSocialProof = containsKeywords(text, valueRules.core_elements.concrete_evidence.types.social_proof.keywords)

  const evidenceCount = [hasNumbers, hasTimeframe, hasSocialProof].filter(Boolean).length

  if (evidenceCount >= 2) {
    score += valueRules.core_elements.concrete_evidence.scoring.multiple_evidence.score
    feedback.push(valueRules.core_elements.concrete_evidence.scoring.multiple_evidence.message)
  } else if (evidenceCount === 1) {
    score += valueRules.core_elements.concrete_evidence.scoring.single_evidence.score
    feedback.push(valueRules.core_elements.concrete_evidence.scoring.single_evidence.message)
    suggestions.push(suggestionTemplates.dimensions.value_proposition.suggestions.add_numbers.template)
  } else {
    feedback.push(valueRules.core_elements.concrete_evidence.scoring.no_evidence.message)
    suggestions.push(suggestionTemplates.dimensions.value_proposition.suggestions.add_numbers.template)
  }

  // 3. å·®ç•°åŒ–è¡¨é”ï¼ˆ25%ï¼‰
  const hasDifferentiation =
    containsKeywords(text, valueRules.core_elements.differentiation.keywords) ||
    matchesPatterns(text, valueRules.core_elements.differentiation.patterns)

  if (hasDifferentiation) {
    score += valueRules.core_elements.differentiation.weight
    feedback.push(valueRules.core_elements.differentiation.scoring.strong_differentiation.message)
  } else {
    feedback.push(valueRules.core_elements.differentiation.scoring.no_differentiation.message)
    suggestions.push(suggestionTemplates.dimensions.value_proposition.suggestions.add_differentiation.template)
  }

  // 4. å¯ä¿¡åº¦æ”¯æŒï¼ˆ20%ï¼‰
  const credibilityTypes = Object.values(valueRules.core_elements.credibility.types)
  const credibilityCount = credibilityTypes.filter(type =>
    containsKeywords(text, type.keywords)
  ).length

  if (credibilityCount >= 2) {
    score += valueRules.core_elements.credibility.scoring.multiple_proofs.score
    feedback.push(valueRules.core_elements.credibility.scoring.multiple_proofs.message)
  } else if (credibilityCount === 1) {
    score += valueRules.core_elements.credibility.scoring.single_proof.score
    feedback.push(valueRules.core_elements.credibility.scoring.single_proof.message)
  } else {
    feedback.push(valueRules.core_elements.credibility.scoring.no_proof.message)
    suggestions.push(suggestionTemplates.dimensions.value_proposition.suggestions.add_social_proof.template)
  }

  // ç¢ºä¿åˆ†æ•¸ä¸è¶…é 100
  score = Math.min(score, 100)

  return { score, feedback, suggestions }
}

// ========== ç”Ÿæˆç¸½çµæ‘˜è¦ ==========

function generateSummary(
  totalScore: number,
  grade: AnalysisResult['grade'],
  dimensions: AnalysisResult['dimensions']
): AnalysisSummary {
  // è¨ˆç®—å„ç¶­åº¦å¾—åˆ†ï¼Œç”¨æ–¼æ‰¾å‡ºå„ªå‹¢å’Œå¼±é»
  const dimensionScores = [
    { name: 'FAB æ³•å‰‡', key: 'fab', score: dimensions.fab.score },
    { name: 'æ¨™é¡Œå¸å¼•åŠ›', key: 'titleAppeal', score: dimensions.titleAppeal.score },
    { name: 'æ¶ˆè²»è€…æ´å¯Ÿ', key: 'consumerInsight', score: dimensions.consumerInsight.score },
    { name: 'è¡Œå‹•å‘¼ç±²', key: 'callToAction', score: dimensions.callToAction.score },
    { name: 'å¯è®€æ€§', key: 'readability', score: dimensions.readability.score },
    { name: 'åƒ¹å€¼ä¸»å¼µ', key: 'valueProposition', score: dimensions.valueProposition.score },
  ]

  // æ’åºæ‰¾å‡ºæœ€å¼·å’Œæœ€å¼±çš„ç¶­åº¦
  const sortedDimensions = [...dimensionScores].sort((a, b) => b.score - a.score)
  const strongest = sortedDimensions.slice(0, 2)
  const weakest = sortedDimensions.slice(-2).reverse()

  // ç”Ÿæˆé¡§å•é¢¨æ ¼çš„æ•´é«”è©•åƒ¹æ®µè½ï¼ˆåŠ å¼·ç‰ˆï¼‰
  let overallAssessment = ''

  // ç¬¬ä¸€æ®µï¼šé–‹å ´è©•èªå’Œç¸½é«”å°è±¡
  if (grade === 'excellent') {
    overallAssessment = `ç¶“éå…¨é¢åˆ†æï¼Œæ‚¨çš„æ–‡æ¡ˆæ•´é«”è¡¨ç¾å„ªç•°ï¼Œç²å¾— ${totalScore} åˆ†çš„é«˜åˆ†ï¼é€™ä»½æ–‡æ¡ˆåœ¨å¤šå€‹é¢å‘éƒ½å±•ç¾äº†å°ˆæ¥­æ°´æº–ï¼Œé¡¯ç¤ºæ‚¨å°æ–¼æ–‡æ¡ˆå¯«ä½œçš„æ ¸å¿ƒåŸå‰‡æœ‰ç›¸ç•¶ç¨‹åº¦çš„æŒæ¡ã€‚`
  } else if (grade === 'good') {
    overallAssessment = `æ•´é«”ä¾†çœ‹ï¼Œæ‚¨çš„æ–‡æ¡ˆå·²ç¶“å…·å‚™ç´®å¯¦çš„åŸºç¤ï¼Œç¸½åˆ†é”åˆ° ${totalScore} åˆ†ã€‚é€™å€‹åˆ†æ•¸é¡¯ç¤ºæ‚¨å·²ç¶“ç†è§£æ–‡æ¡ˆçš„åŸºæœ¬æ¶æ§‹ï¼Œä¸¦ä¸”åœ¨æŸäº›ç¶­åº¦ä¸Šæœ‰ä¸éŒ¯çš„è¡¨ç¾ã€‚`
  } else if (grade === 'needsImprovement') {
    overallAssessment = `ç¶“éä»”ç´°åˆ†æï¼Œæ‚¨çš„æ–‡æ¡ˆç›®å‰ç²å¾— ${totalScore} åˆ†ã€‚é›–ç„¶é‚„æœ‰é€²æ­¥ç©ºé–“ï¼Œä½†é€™å…¶å¯¦æ˜¯å€‹å¾ˆå¥½çš„èµ·é»ï¼é€™å€‹åˆ†æ•¸ä»£è¡¨æ‚¨çš„æ–‡æ¡ˆå·²ç¶“å…·å‚™åŸºæœ¬æ¶æ§‹ï¼Œåªè¦é‡å°å¹¾å€‹é—œéµç’°ç¯€é€²è¡Œå„ªåŒ–ï¼Œå°±èƒ½çœ‹åˆ°é¡¯è‘—çš„æå‡ã€‚æ–‡æ¡ˆå¯«ä½œæ˜¯å¯ä»¥å¿«é€Ÿé€²æ­¥çš„æŠ€èƒ½ï¼Œæ‚¨å·²ç¶“è¸å‡ºé‡è¦çš„ç¬¬ä¸€æ­¥ã€‚`
  } else {
    overallAssessment = `æ„Ÿè¬æ‚¨ä½¿ç”¨æ–‡æ¡ˆå¥æª¢å·¥å…·ï¼é€™ä»½æ–‡æ¡ˆç›®å‰å¾—åˆ° ${totalScore} åˆ†ï¼Œæˆ‘çŸ¥é“é€™å€‹åˆ†æ•¸å¯èƒ½ä¸å¦‚é æœŸï¼Œä½†è«‹åˆ¥æ°£é¤’ã€‚æ–‡æ¡ˆå¯«ä½œç¢ºå¯¦éœ€è¦ä¸€äº›æŠ€å·§å’Œæ–¹æ³•ï¼Œä½†å¥½æ¶ˆæ¯æ˜¯ï¼Œé€™äº›éƒ½æ˜¯å¯ä»¥é€éå­¸ç¿’å’Œç·´ç¿’å¿«é€ŸæŒæ¡çš„ã€‚è¨±å¤šå„ªç§€çš„æ–‡æ¡ˆå‰µä½œè€…ä¹Ÿæ˜¯å¾é›¶é–‹å§‹ï¼Œä¸€æ­¥æ­¥ç´¯ç©ç¶“é©—ã€‚è®“æˆ‘å€‘ä¸€èµ·ä¾†çœ‹çœ‹å¦‚ä½•å„ªåŒ–é€™ä»½æ–‡æ¡ˆï¼Œæ‚¨æœƒç™¼ç¾æ”¹å–„çš„éç¨‹å…¶å¯¦å¾ˆæœ‰æˆå°±æ„Ÿï¼`
  }

  // ç¬¬äºŒæ®µï¼šè©³ç´°çš„å¼·é …åˆ†æ
  overallAssessment += '\n\n'
  if (strongest[0].score >= 70) {
    overallAssessment += `å¾å…­å¤§ç¶­åº¦ä¾†çœ‹ï¼Œæ‚¨åœ¨ã€Œ${strongest[0].name}ã€æ–¹é¢è¡¨ç¾æœ€ç‚ºçªå‡ºï¼Œç²å¾— ${strongest[0].score} åˆ†ã€‚`
    if (strongest[1].score >= 70) {
      overallAssessment += `ã€Œ${strongest[1].name}ã€ä¹Ÿé”åˆ° ${strongest[1].score} åˆ†çš„è‰¯å¥½æ°´æº–ã€‚`
    }
    overallAssessment += 'é€™äº›å„ªå‹¢æ˜¯å¾ˆå¥½çš„åŸºç¤ï¼Œé¡¯ç¤ºæ‚¨å·²ç¶“æŒæ¡äº†é€™äº›é ˜åŸŸçš„é‡é»ã€‚'

    // æ ¹æ“šå¼·é …çµ¦äºˆå…·é«”æ­£é¢å›é¥‹
    if (strongest[0].key === 'fab' && strongest[0].score >= 70) {
      overallAssessment += 'ç‰¹åˆ¥æ˜¯ FAB æ³•å‰‡çš„é‹ç”¨ï¼Œé€™æ˜¯æ–‡æ¡ˆæœ€æ ¸å¿ƒçš„æ¶æ§‹ï¼Œèƒ½åšåˆ°é€™ä¸€é»éå¸¸ä¸å®¹æ˜“ã€‚'
    } else if (strongest[0].key === 'titleAppeal' && strongest[0].score >= 70) {
      overallAssessment += 'å°¤å…¶æ˜¯æ¨™é¡Œçš„å¸å¼•åŠ›ï¼Œå¥½çš„æ¨™é¡Œç­‰æ–¼æˆåŠŸäº†ä¸€åŠï¼Œé€™æœƒå¤§å¹…æå‡æ‚¨çš„é»æ“Šç‡ã€‚'
    }
  } else {
    overallAssessment += `å¾åˆ†æçµæœä¾†çœ‹ï¼Œå…­å¤§ç¶­åº¦ç›®å‰çš„è¡¨ç¾éƒ½é‚„æœ‰å¾ˆå¤§çš„æå‡ç©ºé–“ã€‚é€™ä»£è¡¨æˆ‘å€‘éœ€è¦å¾åŸºç¤é–‹å§‹ï¼Œç³»çµ±æ€§åœ°å¼·åŒ–æ¯å€‹ç’°ç¯€ã€‚`
  }

  // ç¬¬ä¸‰æ®µï¼šé—œéµå¼±é …è¨ºæ–·
  overallAssessment += '\n\n'
  const criticalWeaknesses = dimensionScores.filter(d => d.score < 50)
  if (criticalWeaknesses.length > 0) {
    overallAssessment += `å¦ä¸€æ–¹é¢ï¼Œæˆ‘ç‰¹åˆ¥æ³¨æ„åˆ°ã€Œ${criticalWeaknesses[0].name}ã€ç›®å‰åªæœ‰ ${criticalWeaknesses[0].score} åˆ†ï¼Œ`
    if (criticalWeaknesses.length > 1) {
      overallAssessment += `è€Œã€Œ${criticalWeaknesses[1].name}ã€ä¹Ÿåªæœ‰ ${criticalWeaknesses[1].score} åˆ†ï¼Œ`
    }
    overallAssessment += 'é€™æ˜¯ç›®å‰æœ€éœ€è¦å„ªå…ˆæ”¹å–„çš„éƒ¨åˆ†ã€‚'

    // é‡å° FAB å¼±é …çµ¦äºˆç‰¹åˆ¥æé†’
    if (dimensions.fab.score < 50) {
      overallAssessment += 'ç‰¹åˆ¥è¦æé†’çš„æ˜¯ï¼ŒFAB æ³•å‰‡ï¼ˆç‰¹æ€§ã€å„ªå‹¢ã€æ•ˆç›Šï¼‰æ˜¯æ–‡æ¡ˆçš„æ ¸å¿ƒæ¶æ§‹ï¼Œé€™å€‹éƒ¨åˆ†çš„å¼±åŒ–æœƒç›´æ¥å½±éŸ¿æ–‡æ¡ˆçš„èªªæœåŠ›ã€‚å¾ˆå¤šæ–‡æ¡ˆåªåœç•™åœ¨ã€ŒFeatureï¼ˆç‰¹æ€§ï¼‰ã€çš„å±¤é¢ï¼Œå»å¿˜äº†å‘Šè¨´è®€è€…ã€Œå°æˆ‘æœ‰ä»€éº¼å¥½è™•ï¼ˆBenefitï¼‰ã€ï¼Œé€™æ˜¯æœ€å¸¸è¦‹ä¹Ÿæœ€è‡´å‘½çš„éŒ¯èª¤ã€‚'
    }
  } else if (weakest[0].score < 60) {
    overallAssessment += `ç›¸å°è€Œè¨€ï¼Œã€Œ${weakest[0].name}ã€å¾—åˆ† ${weakest[0].score} åˆ†ï¼Œæ˜¯ç›®å‰æ¯”è¼ƒéœ€è¦åŠ å¼·çš„ç’°ç¯€ã€‚`
    if (weakest[1].score < 60) {
      overallAssessment += `ã€Œ${weakest[1].name}ã€ï¼ˆ${weakest[1].score} åˆ†ï¼‰ä¹Ÿå€¼å¾—é—œæ³¨ã€‚`
    }
  }

  // ç¬¬å››æ®µï¼šå…·é«”çš„æ”¹å–„æ–¹å‘å’Œé¼“å‹µ
  overallAssessment += '\n\n'
  if (grade === 'excellent') {
    overallAssessment += 'ä»¥æ‚¨ç›®å‰çš„æ°´æº–ï¼Œæ¥ä¸‹ä¾†å¯ä»¥æœå‘ã€Œç²¾ç›Šæ±‚ç²¾ã€çš„æ–¹å‘åŠªåŠ›ã€‚å»ºè­°æ‚¨é‡å°ä¸åŒçš„ç›®æ¨™å—çœ¾é€²è¡Œ A/B æ¸¬è©¦ï¼Œé€éæ•¸æ“šå›é¥‹ä¾†å¾®èª¿æ–‡æ¡ˆçš„æ¯å€‹ç´°ç¯€ã€‚åŒæ™‚ï¼Œä¹Ÿå¯ä»¥é–‹å§‹ç ”ç©¶æ›´é€²éšçš„æ–‡æ¡ˆæŠ€å·§ï¼Œä¾‹å¦‚æ•…äº‹è¡ŒéŠ·ã€æƒ…æ„Ÿé€£çµç­‰æ‰‹æ³•ã€‚'
  } else if (grade === 'good') {
    overallAssessment += 'æ‚¨çš„æ–‡æ¡ˆå·²ç¶“æœ‰ 60 åˆ†ä»¥ä¸Šçš„æ°´æº–ï¼Œåªè¦é‡å°å¹¾å€‹é—œéµé»é€²è¡Œèª¿æ•´ï¼Œå°±èƒ½è®“æ•ˆæœæ›´ä¸Šä¸€å±¤æ¨“ã€‚å»ºè­°æ‚¨ç‰¹åˆ¥é—œæ³¨ä¸‹æ–¹çš„ã€Œå„ªå…ˆæ”¹å–„å»ºè­°ã€ï¼Œé€™äº›éƒ½æ˜¯ç¶“éåˆ†æå¾Œæœ€å€¼å¾—æŠ•å…¥æ™‚é–“å„ªåŒ–çš„éƒ¨åˆ†ã€‚æ¯æ”¹å–„ä¸€å€‹å¼±é»ï¼Œéƒ½æœƒç‚ºæ‚¨çš„æ–‡æ¡ˆåŠ åˆ†ã€‚'
  } else if (grade === 'needsImprovement') {
    overallAssessment += 'å»ºè­°æ‚¨å…ˆå¾ä¸‹æ–¹åˆ—å‡ºçš„ã€Œå„ªå…ˆæ”¹å–„å»ºè­°ã€é–‹å§‹ï¼Œä¸€æ­¥æ­¥å„ªåŒ–æ–‡æ¡ˆå“è³ªã€‚ä¸ç”¨æ€¥è‘—ä¸€æ¬¡æ”¹å–„æ‰€æœ‰é …ç›®ï¼Œå…ˆå¾æœ€é—œéµçš„ 2-3 å€‹é‡é»è‘—æ‰‹å°±å¥½ã€‚å¾ˆå¤šå­¸å“¡éƒ½æ˜¯å¾é€™å€‹éšæ®µé–‹å§‹ï¼ŒæŒ‰ç…§å»ºè­°èª¿æ•´å¾Œï¼Œå¾€å¾€åœ¨å¾ˆçŸ­çš„æ™‚é–“å…§å°±èƒ½çœ‹åˆ°æ˜é¡¯é€²æ­¥ã€‚ç›¸ä¿¡æ‚¨ä¹Ÿå¯ä»¥åšåˆ°ï¼'
  } else {
    overallAssessment += 'å»ºè­°æ‚¨å¯ä»¥å¾ FAB æ³•å‰‡ï¼ˆç‰¹æ€§ã€å„ªå‹¢ã€æ•ˆç›Šï¼‰é€™å€‹æ ¸å¿ƒæ¦‚å¿µé–‹å§‹ã€‚è©¦è‘—å•è‡ªå·±ä¸‰å€‹ç°¡å–®çš„å•é¡Œï¼šã€Œæˆ‘çš„ç”¢å“/æœå‹™æ˜¯ä»€éº¼ï¼Ÿï¼ˆFeatureï¼‰ã€ã€ã€Œå®ƒè·Ÿåˆ¥äººæœ‰ä»€éº¼ä¸åŒï¼Ÿï¼ˆAdvantageï¼‰ã€ã€ã€Œé€™èƒ½ç‚ºå®¢æˆ¶å¸¶ä¾†ä»€éº¼å¥½è™•ï¼Ÿï¼ˆBenefitï¼‰ã€ã€‚ç•¶æ‚¨èƒ½æ¸…æ¥šå›ç­”é€™ä¸‰å€‹å•é¡Œï¼Œä¸¦ç”¨æ·ºé¡¯æ˜“æ‡‚çš„æ–¹å¼è¡¨é”å‡ºä¾†æ™‚ï¼Œæ–‡æ¡ˆçš„å¸å¼•åŠ›å°±æœƒå¤§å¹…æå‡ã€‚é€™æ˜¯ä¸€å€‹ç·´ç¿’çš„éç¨‹ï¼Œå¤šå¯«å¹¾æ¬¡å°±æœƒè¶Šä¾†è¶Šé †æ‰‹ï¼'
  }

  // å„ªå‹¢åˆ†æ
  const strengths: string[] = []
  strongest.forEach(dim => {
    if (dim.score >= 70) {
      strengths.push(`${dim.name}è¡¨ç¾å„ªç•°ï¼ˆ${dim.score}åˆ†ï¼‰`)
    }
  })
  if (strengths.length === 0) {
    strengths.push('å»ºè­°å…¨é¢å„ªåŒ–å„å€‹ç¶­åº¦')
  }

  // å¼±é»åˆ†æ
  const weaknesses: string[] = []
  weakest.forEach(dim => {
    if (dim.score < 60) {
      weaknesses.push(`${dim.name}éœ€è¦åŠ å¼·ï¼ˆ${dim.score}åˆ†ï¼‰`)
    }
  })

  // æ”¶é›†æœ€é‡è¦çš„å»ºè­°ï¼ˆå¾æœ€å¼±çš„ç¶­åº¦ä¸­å–ï¼‰
  const topPriorities: string[] = []

  // FAB æ³•å‰‡å„ªå…ˆï¼ˆæœ€é‡è¦ï¼‰
  if (dimensions.fab.score < 60 && dimensions.fab.suggestions.length > 0) {
    topPriorities.push(...dimensions.fab.suggestions.slice(0, 2))
  }

  // å…¶ä»–å¼±é»ç¶­åº¦çš„å»ºè­°
  weakest.forEach(dim => {
    const dimKey = dim.key as keyof typeof dimensions
    if (dim.score < 60 && dimensions[dimKey].suggestions.length > 0) {
      topPriorities.push(...dimensions[dimKey].suggestions.slice(0, 1))
    }
  })

  // é™åˆ¶åœ¨ 3-5 æ¢æœ€é‡è¦çš„å»ºè­°
  const finalPriorities = topPriorities.slice(0, 5)

  // é æœŸæ•ˆæœ
  let expectedImpact = ''
  if (totalScore >= 80) {
    expectedImpact = 'æŒçºŒå„ªåŒ–å¯ç¶­æŒé«˜è½‰æ›ç‡ï¼Œå»ºè­°é€²è¡Œ A/B æ¸¬è©¦æ‰¾å‡ºæœ€ä½³ç‰ˆæœ¬ã€‚'
  } else if (totalScore >= 60) {
    expectedImpact = 'æŒ‰å»ºè­°èª¿æ•´å¾Œï¼Œé æœŸè½‰æ›ç‡å¯æå‡ 20-40%ã€‚'
  } else if (totalScore >= 40) {
    expectedImpact = 'é‡é»å„ªåŒ–å¼±é …å¾Œï¼Œé æœŸè½‰æ›ç‡å¯æå‡ 40-60%ã€‚'
  } else {
    expectedImpact = 'æ¡ç”¨ FAB æ³•å‰‡é‡æ–°æ¶æ§‹å¾Œï¼Œé æœŸè½‰æ›ç‡å¯æå‡ 60-100% ä»¥ä¸Šã€‚'
  }

  // Vista èª²ç¨‹èˆ‡å­¸ç¿’è³‡æºæ¨è–¦
  let vistaRecommendation = ''
  if (grade === 'excellent' || grade === 'good') {
    vistaRecommendation = 'å¦‚æœæ‚¨æƒ³é€²ä¸€æ­¥ç²¾é€²æ–‡æ¡ˆèˆ‡å…§å®¹è¡ŒéŠ·èƒ½åŠ›ï¼Œæ¨è–¦ Vista åœ¨ Hahow é–‹è¨­çš„ã€Šå…§å®¹åŠ›ï¼šæ‰“é€ å“ç‰Œçš„è¶…èƒ½åŠ›ã€‹ç·šä¸Šèª²ç¨‹ï¼Œæ·±å…¥æ¢è¨å…§å®¹ç­–ç•¥ã€å“ç‰Œå®šä½èˆ‡å¯¦æˆ°æ‡‰ç”¨ã€‚æ­¤å¤–ï¼ŒVista çš„ç³»åˆ—è‘—ä½œæ¶µè“‹æ–‡æ¡ˆå¯«ä½œã€å…§å®¹å‰µä½œã€ä»¥åŠ ChatGPT æ‡‰ç”¨ç­‰ä¸»é¡Œï¼Œæä¾›è±å¯Œçš„å¯¦æˆ°æ¡ˆä¾‹å’Œæ–¹æ³•è«–ï¼Œèƒ½å¹«åŠ©æ‚¨å°‡å°ˆæ¥­æŠ€èƒ½æå‡åˆ°æ›´é«˜å±¤æ¬¡ã€‚'
  } else if (grade === 'needsImprovement') {
    vistaRecommendation = 'æƒ³è¦ç³»çµ±æ€§åœ°æå‡å…§å®¹å‰µä½œèˆ‡æ–‡æ¡ˆèƒ½åŠ›å—ï¼ŸVista åœ¨ Hahow é–‹è¨­çš„ã€Šå…§å®¹åŠ›ï¼šæ‰“é€ å“ç‰Œçš„è¶…èƒ½åŠ›ã€‹ç·šä¸Šèª²ç¨‹ï¼Œå°ˆé–€ç‚ºè¡ŒéŠ·äººå“¡å’Œå…§å®¹å‰µä½œè€…è¨­è¨ˆï¼Œå¾å“ç‰Œå®šä½ã€å…§å®¹ç­–ç•¥åˆ°å¯¦æˆ°æŠ€å·§ï¼Œéƒ½æœ‰å®Œæ•´çš„æ•™å­¸èˆ‡ç·´ç¿’ã€‚æ­é… Vista çš„æ–‡æ¡ˆã€å¯«ä½œèˆ‡ ChatGPT æ‡‰ç”¨æ›¸ç±ï¼Œèƒ½å¹«åŠ©æ‚¨å¿«é€ŸæŒæ¡æ ¸å¿ƒæŠ€å·§ï¼Œé¿å…å¸¸è¦‹éŒ¯èª¤ï¼Œå»ºç«‹å°ˆæ¥­å…§å®¹å‰µä½œèƒ½åŠ›ã€‚'
  } else {
    vistaRecommendation = 'å…§å®¹å‰µä½œèˆ‡æ–‡æ¡ˆå¯«ä½œæ˜¯å¯ä»¥å­¸ç¿’çš„æŠ€èƒ½ï¼Vista åœ¨ Hahow çš„ã€Šå…§å®¹åŠ›ï¼šæ‰“é€ å“ç‰Œçš„è¶…èƒ½åŠ›ã€‹ç·šä¸Šèª²ç¨‹ï¼Œç‰¹åˆ¥é©åˆåˆå­¸è€…ï¼Œå¾åŸºç¤è§€å¿µã€FAB æ³•å‰‡åˆ°å®Œæ•´çš„å…§å®¹ç­–ç•¥ï¼Œéƒ½æœ‰ç³»çµ±åŒ–çš„æ•™å­¸ã€‚Vista çš„ç³»åˆ—è‘—ä½œæ›´è©³ç´°è§£ææ–‡æ¡ˆæ’°å¯«ã€å…§å®¹è¦åŠƒï¼Œä»¥åŠå¦‚ä½•é‹ç”¨ ChatGPT æå‡å‰µä½œæ•ˆç‡ã€‚å»ºè­°æ‚¨å¾é€™äº›è³‡æºé–‹å§‹å­¸ç¿’ï¼ŒçŸ­æ™‚é–“å…§å°±èƒ½çœ‹åˆ°æ˜é¡¯é€²æ­¥ã€‚'
  }

  return {
    overallAssessment,
    strengths,
    weaknesses: weaknesses.length > 0 ? weaknesses : ['å„ç¶­åº¦å‡æœ‰æå‡ç©ºé–“'],
    topPriorities: finalPriorities,
    expectedImpact,
    vistaRecommendation,
  }
}

// ========== ä¸»è¦åˆ†æå‡½æ•¸ ==========

export async function analyzeCopywriting(text: string): Promise<AnalysisResult> {
  // æ¨¡æ“¬åˆ†æå»¶é²ï¼ˆçµ¦ä½¿ç”¨è€…æ›´å¥½çš„é«”é©—æ„Ÿï¼‰
  await new Promise(resolve => setTimeout(resolve, 800))

  // åŸ·è¡Œå„ç¶­åº¦åˆ†æ
  const dimensions = {
    fab: analyzeFAB(text),
    titleAppeal: analyzeTitleAppeal(text),
    consumerInsight: analyzeConsumerInsight(text),
    callToAction: analyzeCallToAction(text),
    readability: analyzeReadability(text),
    valueProposition: analyzeValueProposition(text),
  }

  // è¨ˆç®—ç¸½åˆ†ï¼ˆFAB ä½œç‚ºæœ€æ ¸å¿ƒçš„ç¶­åº¦ï¼Œçµ¦äºˆæ›´é«˜æ¬Šé‡ï¼‰
  const totalScore = Math.round(
    (dimensions.fab.score * 0.25 +
      dimensions.titleAppeal.score * 0.15 +
      dimensions.consumerInsight.score * 0.15 +
      dimensions.callToAction.score * 0.15 +
      dimensions.readability.score * 0.15 +
      dimensions.valueProposition.score * 0.15)
  )

  // æ ¹æ“šç¸½åˆ†åˆ¤å®šç­‰ç´š
  let grade: AnalysisResult['grade']
  if (totalScore >= SCORE_THRESHOLDS.EXCELLENT) {
    grade = 'excellent'
  } else if (totalScore >= SCORE_THRESHOLDS.GOOD) {
    grade = 'good'
  } else if (totalScore >= SCORE_THRESHOLDS.NEEDS_IMPROVEMENT) {
    grade = 'needsImprovement'
  } else {
    grade = 'needsRewrite'
  }

  // ç”Ÿæˆç¸½çµæ‘˜è¦
  const summary = generateSummary(totalScore, grade, dimensions)

  return {
    totalScore,
    grade,
    summary,
    dimensions,
    analyzedText: text,
    timestamp: new Date(),
  }
}
